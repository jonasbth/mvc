{% extends "base.html.twig" %}

{% block title %}Rapport | mvc{% endblock %}

{% block body %}
    <article class="no-flex">
        <h1>Redovisning av kursmoment i kursen mvc (v2)</h1>
        <nav>
            <ul>
                <li><a href="#kmom01">Kmom01</a></li>
                <li><a href="#kmom02">Kmom02</a></li>
                <li><a href="#kmom03">Kmom03</a></li>
                <li><a href="#kmom04">Kmom04</a></li>
                <li><a href="#kmom05">Kmom05</a></li>
                <li><a href="#kmom06">Kmom06</a></li>
                <li><a href="#kmom10">Kmom10</a></li>
            </ul>
        </nav>

        <section>
            <h2 id="kmom01">Kmom01</h2>
            <p>Då är vi igång med en ny kurs, Objektorienterade webbteknologier, eller mvc i dagligt tal. Jag har sysslat en del med objektorienterad
               programmering innan jag började på BTH. När jag började på ett konsultbolag i början av 2000-talet, så gick jag några kurser i
               objektorientering och C++ hos Learning Tree, ett bolag som fortfarande är verksamt konstaterade jag precis. Nu hittar jag bara att de
               har en introduktionskurs till C++. När jag gick deras kurser så fanns det flera och mer avancerade C++-kurser.</p>

            <p>Under min tid på ett konsultbolag var jag inblandad i ett par större projekt där objektorienterad C++ användes. Nu senast läste jag
               också en kurs i objektorienterad Python på BTH. Just i PHP, som används i denna kurs, har jag dock inte använt objektorientering.</p>

            <p>För att prata lite om hur objektorienterad programmering ser ut i PHP, så liknar den nog mer den traditionella modellen som den ser
               ut i C++, än som den ser ut i Python, där det till exempel inte går att göra medlemsvariabler privata, utan det kan bara ske genom
               en konvention hur man namnger en variabel. I PHP använder man det reserverade ordet <code>class</code> för att definera klassens
               egenskaper (properties) och metoder. Inuti en metod kan man använda namnet <code>$this</code> för att referera till det egna objektet.
               För att referera till en statisk (klass-) variabel, så använder man istället <code>self::</code> framför variabelnamnet.</p>

            <p>En konstruktor är en funktion som anropas då ett objekt instantieras. I PHP namnger man konstruktorn med <code>__construct()</code>.
               För att instantiera ett objekt av en klass använder man som i de flesta andra språk nyckelordet <code>new</code>. Man kan se en
               klass som en definition av en komplex datatyp som både innehåller en beskrivning av ett tillstånd genom medlemsvariabler och funktioner
               genom s.k. metoder. Klassen används som en mall när man instantierar objekt av klassen. Ett viktigt begrepp inom objektorientering är
               inkapsling (encapsulation), som syftar på att objekt har egenskaper (tillstånd) och egna metoder som kan operera dessa, och egenskaperna
               kan göras privata, så att de inte kan modifieras utanför objekten.</p>

            <p>Största arbetet med kursmomentet var att komma igång med PHP-ramverket Symfony och skapa och designa en mindre webbplats med hjälp
               av detta. En fördel med Symfony är att det är enkelt att definiera "routes" till webbplatsen, där man kopplar ihop en sökväg (URL)
               med en templatefil som renderar webbsidan. I Symfony används Twig som templatemotor, vilket även används i det lilla ramverket
               Pico, som vi använde i designkursen. Vi gjorde även en liten API-metod, som returnerade ett JSON-svar, här användes dock inte Twig.</p>

            <p>För att packa ihop och komprimera CSS-filer och JavaScript installerade vi Encore, som är en paketering (wrapping) av Webpack,
               gjord av Symfony, för att förenkla hanteringen av Webpack. En reflektion är att Symfony är ett tämligen stort och lite tungt
               ramverk. Komprimeringen av CSS och JavaScript tar några sekunder, som dock bara behöver göras när man ändrat i någon resursfil, och
               det är en märkbar fördröjning på någon sekund när en ocachad webbsida laddas. Tittar man i var/cache/ ser man att det är några
               tusen cachade filer bara för vår lilla webbplats.</p>

            <p>Slutligen skall vi lyfta fram några delar av artikeln <a href="https://phptherightway.com/">PHP The Right Way</a>. Känslan är att
               artikeln tar upp mycket som vi redan stött på i denna kurs och i tidigare kurserna Webtec och Design. Det verkar vara en bra källa,
               som innehåller mycket länkar till användbara resurser inom PHP. Saker som vi inte ännu berört så mycket är SPL (Standard PHP
               Library), säkerhet, virtualisering, caching och dokumentation. I JavaScript-kursen använde vi JSDoc för dokumentation, en gissning
               är att PHPDoc fungerar på liknande sätt.</p>

            <p>TIL för detta kursmoment är introduktionen till ramverket Symfony.</p>

        </section>

        <section>
            <h2 id="kmom02">Kmom02</h2>
            <p>I kursmoment 2 fortsätter vi med objektorientering i PHP och Symfony, och skapar modellklasser för en kortlek.</p>

            <p>Inom objektorientering
               finns det konstruktioner som arv, komposition, interface och trait. Arv kännetecknas av att det finns en basklass (även kallad
               förälderklass eller superklass), och subklasser ("barnklasser") som specialiserar eller utökar funktionen hos basklassen. En
               arvskonstruktion kan vara lämplig att använda när man kan formulera en relation mellan klasser med hjälp av uttrycket "a är en b",
               t ex "en Volvo är en bil", där då "bil" representerar en basklass och "Volvo" en subklass. I PHP använder man nyckelordet "extends"
               för att skapa ett arv mellan klasser.</p>

            <p>En annan konstruktion är komposition, som innebär att en klass har en annan klass som attribut. Det vill säga en klass äger, har eller
               består av en eller flera andra klasser. Det finns några olika grader av komposition: En svagare typ kallar man för aggregation,
               som innebär att objekt som finns inuti ett annat objekt kan existera utanför det inneslutande objektet. Med ren komposition menar
               man att objekt som är inneslutna i ett annat inte kan existera självständigt. Exempel på det senare skulle kunna vara rum i ett
               hus, som inte kan existera utan huset. I vårat fall med kort i en kortlek, så handlar förhållandet mellan klasserna snarast om
               aggregation: Ett spelkort kan ha ett liv utanför kortleken, till exempel i en korthand.</p>

            <p>Enligt regelboken är komposition är att föredra om både arv och komposition är möjliga konstruktioner. Det leder till flexiblare och
               "snyggare" kod. Av egen erfarenhet vet jag att djupa arvshierarkier leder till kod som är svår att underhålla, och hitta fel i.</p>

            <p>Ett interface anger en uppsättning metoder som en klass som implementerar interfacet lovar att uppfylla. Ett interface kan ses som
               ett kontrakt, det innehåller metodnamn och parametrar, men ingen implementation. En variant på interface är en abstrakt basklass,
               som inte heller kan instantieras, men som kan ha vissa metoder implementerade och även ha attribut.</p>

            <p>Slutligen med konstruktionen trait kan man skapa återanvändbar kod som löser ett specifikt problem. En trait ser ut som en klass
               men kan inte instantieras. För att använda en trait i en klass, så använder man nyckelordet "use" följt av namnet på traiten.</p>

            <p>Nu ska vi prata om den egna implementation av uppgiften i kursmomentet. Jag har beskrivit klasserna, med ett klassdiagram på
               <a href="{{ path('card_index') }}">landningssidan för kortleken</a>. Jag är nöjd med hur jag skapade en abstrakt basklass för
               spelkorten, och specialiseringen i subklasser för de olika kortfärgerna eller sviterna. Extra nöjd är jag nog med metoden
               <code>getSuit()</code>, som jag implementerade i basklassen, och som returnerar det egna kortets färg med hjälp av klassnamnet.
               Det kan vara ett exempel på så kallad polymorfism, som är egenskap av arv i objektorientering, och som innebär att en metod
               kan bete sig olika beroende av den konkreta typen av objektet.</p>

            <p>Även metoden <code>getHTMLEntity()</code>, som jag specialiserade i subklasserna är ett uttryck av polymorfism. Den metoden
               returnerar en HTML-entitet, som ger en enkel grafisk beskrivning av ett kort. Jag gillar att det är ett resurssnålt sätt att
               beskriva ett kort och att det använder en "native" webbteknologi. Användarna av webbsidorna är kanske mindre imponerade.</p>

            <p>För klasserna <code>CardDeck</code> och <code>CardHand</code> är jag nöjd med att jag implementerade interface:en
               <code>Iterator</code> och <code>Countable</code>, vilket gör det enkelt att iterera över korten både i PHP och i Twig-filerna.
               Lite mindre nöjd är jag kanske över att jag implementerade metoden <code>shuffle()</code> själv, trots att det finns en
               inbyggd funktion shuffle i PHP, vilket jag upptäckte senare. Men det gav i alla fall lite extra träning.</p>

            <p>En kort kommentar om att jag i <code>CardHand</code>-klassen använder "dependency injection", dvs. jag "skapar" korten utanför
               korthanden och skickar in dem i konstruktorn. Däremot i <code>CardDeck</code>, så skapar klassen sina egna kort med hjälp av
               <code>reset()</code>-metoden. Dock har jag några klasskonstanter som beskriver korten, och gör det lite mera flexibelt.</p>

            <p>Slutligen en kommentar om JSON API:et: Vi skulle skapa POST-router för ett antal förfrågningar, där jag tycker att GET vore mera logiskt,
               eftersom vi egentligen inte skickar någon data till routen. Därför tillåter jag både GET- och POST-anrop till de aktuella
               routerna och hoppas att det är acceptabelt.</p>

            <p>Nu har jag gått över 30 meningar, så det får bli en kort reflektion om att arbeta med Symfony och MVC. Jag är inte speciellt
               road av att jobba med ett "gigantiskt" ramverk som Symfony. Dokumentationen är dessutom ofullständig, så man får söka svar i
               källkoden om det är något lite udda man undrar över. En fördel med ramverket är att det är lätt att skapa "routes" till
               applikationen, och Twig är också trevligt att jobba med. Men applikationen känns tung, och man har liten koll på vad som
               egentligen händer bakom kulisserna. Men det är ju alltid en erfarenhet.</p>

            <p>TIL för detta kursmoment är implementeringen av interface:en <code>Iterator</code> och <code>Countable</code>.</p>

            <p></p>

        </section>

        <section>
            <h2 id="kmom03">Kmom03</h2>
            <p>Kursmoment 3 handlar om att fortsätta med objektorientering i PHP och skapa en lite större applikation i form av ett kortspel.
               Vi använder också några verktyg för kodvalidering och försöker skapa en snygg kod.</p>

            <p>Jag valde standardalternativet, att skapa en applikation för kortspelet 21, och gjorde några av de föreslagna extrauppgifterna,
               specifikt de som handlade om korträkning för att ge en hjälp till spelaren, och att skapa en lite smartare bank.</p>

            <p>Först skulle vi planera kodningen med hjälp av flödesdiagram och pseudokod. Jag har programmerat i några år och aldrig använt
               någon av dessa tekniker, så det gav upphov till en hel del ångest. Enligt kraven skulle det räcka att lösa en del av uppgiften
               på detta sätt, så jag valde specifikt funktionen för den "smarta" banken och gjorde den delen mot slutet, när jag hade en
               fungerande applikation i övrigt. </p>

            <p>Som jag hade på känn så är det ett väldigt omständligt och tidskrävande sätt att arbeta. Det
               tar kanske uppemot fem gånger så lång tid att skapa flödesdiagram, pseudokod och vanlig kod, som att skriva koden direkt.
               Till exempel så upptäckte jag ett litet tankefel när jag skulle skriva den vanliga koden, och fick då uppdatera flödesdiagrammet
               och pseudokoden för att de skulle överensstämma. En fördel kan vara att problemet blir belyst från flera håll och ordenligt
               genomarbetat, men frågan är om det är värt tiden det tar? Av de två teknikerna är det flödesdiagrammet som kan vara mest
               givande, pseudokoden var betydligt svårare att skriva, och den kräver nog mycket träning i sig för att bli användbar.
               Flödesdiagrammet kan också vara bra för att dokumentera koden, men det kan bli jobbigt att uppdatera om koden ändras.</p>

            <p>Jag funderade lite på hur jag löste uppgiften i övrigt utan flödesdiagram, och kom fram till att jag använder en bottom-up teknik:
               Jag börjar med att implementera en liten konkret del i spelet, som att dela ut ett kort till spelaren, och fortsätter sedan att
               bygga på med funktionalitet. För mig hade det varit betydligt svårare att jobba top-down, att starta med ett "blankt papper" och
               försöka fundera ut hur allt skulle hänga ihop med en gång.</p>

            <p>När jag hade fått ihop ett fungerande spel, så visade det sig att den mesta logiken låg i controller-klasserna, så jag gjorde
               en "refactoring" av koden genom att skapa en modellklass <code>Game21</code> för spelet, där jag lade all logik. I klassen
               finns också alla variabler för tillståndet i spelet, och get-metoder för att läsa av variablerna. PHP Mess Detector (PHPMD)
               klagade på att det finns för många publika metoder i klassen <code>Game21</code>. De flesta av dessa är get-metoder för
               variablerna. Jag funderade lite på att lägga alla variabler i en separat dataklass, men det hade fortfarande blivit fler än
               10 publika metoder i en sådan, så PHPMD hade i alla fall inte blivit nöjd. Jag kan inte heller se att det hade förenklat koden.</p>

            <p>Vad gäller förbättringspotential i applikationen, så skulle man kunna arbeta mer på layouten i spelplanen, för att få en
               lite mera riktig spelkänsla med en fast spelplan, som inte ändrar sig så mycket beroende av läget i spelet. Som det är nu
               fyller jag bara på med information enligt en "normal-flow" metod nedåt på skärmen när det behövs.</p>

            <p>Angående förbättringspotential i koden, så ser i alla fall PHPMD att det finns en sådan vad gäller storleken av spelklassen,
               som jag beskrev ovan. Vidare så anmärker PHPMD på alla if-else-konstruktioner, varav det finns en del. Jag håller med om
               att det är möjligt att klara sig utan else &mdash; genom att ge ett default värde, som man sedan ändrar med enkla if-satser
               vid behov. Det kan vara en bra strategi om det finns ett tydligt alternativ som är det vanliga, men om alternativen är
               likvärdiga så behöver det inte vara det bästa.</p>

            <p>Verktyget PHPStan blev till slut nöjt med min kod. Efter några timmars svettande och letande på nätet så lyckade jag passera
               alla nio nivåer. Det var vid nivå sex som det började dyka upp lite fler anmärkningar, det handlade om typer i arrayer,
               som man kan ange med hjälp av så kallade DocBlocks. I allmänhet så kunde man lösa de flesta av PHPStans anmärkningar med
               hjälp av DocBlocks.</p>

            <p>Verktyget PHP Coding Standards Fixer (PHP CS Fixer), som tillhandahålls via Symfony, hittade några fel mest relaterat till
               placering av klammerparenteser eller "måsvingar". Verktyget är lite omständligt att använda eftersom det endast automatiskt
               fixar koden, vilket jag inte gillar. Så jag gör så att jag kör en dry-run med verktyget och noterar vilka filer som kommer
               att ändras, sparar dessa filer i en annan mapp, och kör verktyget igen i skarpt läge. Sedan kan man göra en diff för att se
               vilka ändringar som gjorts.</p>

            <p>Vad tycker jag om att koda i Symfony så här långt? I förra kursmomentet uttryckte jag en del kritik, och tyckte att det var
               stort, segt och icke-transparent, mycket händer i bakgrunden men man vet inte vad. Genom att avaktivera debug-toolbaren,
               som jag provade i detta kursmoment, så blir applikationen lite rappare om mindre "hoppig" i layouten vid navigeringar och
               omladdningar. En "fara" är att man vänjer sig vid de konstruktioner som Symfony erbjuder, och glömmer bort hur det fungerar
               i ren PHP utan ramverk. Det blir en "vendor lock-in" effekt.</p>

            <p>TIL:en för kursmomentet får bli arbetet med kodfixningen för att få PHPStan att bli nöjt.</p>

            <p>En sista kommentar om att jag inte nått upp till 20 commits. Jag har i alla fall förbättrat mig jämfört med förra kursmomentet,
               då jag gjorde 4 commits. Det här kursmomentet tycker jag att jag varit flitig och kommit upp i 8 commits, dvs. 12 stycken
               totalt. Att committa allt för halvfärdig kod tycker jag inte känns bra. Jag föredrar att ha en tämligen färdig funktion för
               att committa. Backup till en annan hårddisk gör jag nästan dagligen, så den funktionen är jag inte så beroende av.</p>

        </section>

        <section>
            <h2 id="kmom04">Kmom04</h2>
            <p>I detta kursmoment provar vi på enhetstestning med PHPUnit och dokumentation med phpDoc. Enhetstester skrivs ofta av den som
               utvecklat koden, och kan därför anpassas för att testa så många delar av koden och specialfall som möjligt. Vi strävar efter hög
               kodtäckning. Men kodtäckning i sig är inte ett fullständigt mått på om koden är bra testad, det gäller också att skriva relevanta
               testfall, och att ha genomtänkta så kallade asserts, så att all avsedd funktionalitet verkligen testas.</p>

            <p>Det gick tämligen smärtfritt att komma igång att skriva testfall med PHPUnit. Man skapar en katalogstruktur för testklasserna som
               efterliknar den för koden som skall testas, med minst en testklass per källkodsklass. Sedan låter man testklasserna ärva ifrån
               basklassen <code>TestCase</code>, så att man får tillgång till alla faciliteter i PHPUnit, t ex alla asserts.</p>

            <p>Jag använde mig av så kallade fixtures i testerna för att köra lite gemensam kod för alla tester i en klass, genom att använda
               metoderna <code>setUp()</code> och <code>tearDown()</code>. På så sätt sparar man några rader kod. För testen av <code>Game21</code>-
               klassen använde jag mig istället av en delad fixture för alla tester, genom att använda metoden <code>setUpBeforeClass()</code>.
               Det enda jag gör i den metoden är att instantiera <code>Game21</code>, som bara har en default konstruktor, så det är inte
               jättemycket vunnet i rader kod med det, men det kanske sparar några CPU-cykler?</p>

            <p>Det var lite utmanande att försöka nå 100% kodtäckning i testerna. Relativt enkelt var det i kortklasserna och klasserna för en kortlek
               och en korthand. Mest utmanande var det i spelklassen <code>Game21</code>. Till exempel har jag på ett ställe i koden ett villkor
               som kollar om det finns några kort kvar i kortleken, och eftersom kortleken från början har 52 kort, så måste man spela ett flertal
               rundor för att kunna testa det villkoret. För att underlätta det testet, och också för att lättare kunna testa andra aspekter av
               spelet när det är få kort kvar, så införde jag en möjlighet att skapa en kortlek med färre antal sviter än normalfallet med fyra.
               Till exempel kan man skapa en kortlek med en svit, t ex spader, på endast 13 kort. Då går det enklare att testa själva
               "slutspelet" av spelet.</p>

            <p>Ett annat problem vid testerna är att kortleken är slumpmässigt sorterad, vilket gör det svårt att testa alla möjliga poängsituationer
               som kan uppstå, till exempel om man drar ett ess, så kan det vara värt ett eller fjorton. Så för att mera precist kunna testa
               olika korthänder, så lade jag till en möjlighet i <code>draw()</code>-metoden i <code>CardDeck</code>-klassen att välja vilken
               valör av korten man önskar dra från kortleken. Finns inte den önskade valören kvar i kortleken, så dras inget kort i dess ställe,
               så man måste ha lite koll på de dragna korten när man skriver testerna. Jag tycker att jag fick det att fungera bra, och det
               underlättade att testa alla specialfall, så jag nådde 100% kodtäckning i <code>Game21</code>-klassen.</p>

            <p>En plump i kodtäckningsrapporten är att tester saknas för kontrollklasserna. Jag såg i dokumentationen för Symfony att man kan
               göra så kallade <a href="https://symfony.com/doc/current/testing.html#application-tests">applikationstester</a> för att testa
               requester och responser, men det kändes som en lite för stor uppgift att ge sig i kast med.</p>

            <p>En fråga vi skulle fundera över är om den egna koden är testbar, och även om testbar kod innebär snygg och ren kod. Det är lite
               svårt att bedöma den egna koden, men med de tillägg jag gjorde enligt beskrivningen ovan, så lyckades jag testa koden hyfsat bra.
               Sen är det svårt att avgöra om testbar kod på något sätt innebär snygg kod, kanske inte nödvändigtvis, men det underlättar.
               I begreppet snygg kod skulle man också kunna innefatta effektivt kod, som går snabbt att exekvera och som är snål vad gäller
               minneskrav. Även kod som utnyttjar programmeringsspråkets möjligheter och resulterar i lite källkod tycker jag man
               kan kalla för snygg, men det gäller att hitta en lagom nivå, så att koden inte blir svårtydd.</p>

            <p>En specifik TIL för kursmomentet var att jag kom på att man i de så kallade docblocken bara får ha ett mellanslag mellan
               * och @param- och @return-taggarna, annars parsas inte taggarna av phpDoc. Jag hade inledningsvis två mellanslag efter *,
               för att jag tyckte det gav ett luftigare intryck, men det är alltså ingen bra idé.</p>

            <p>En annan sak jag provade i kursmomentet var en grafisk klient till Git kallad <a href="https://github.com/git-cola/git-cola">
               Git Cola</a>, vilken fungerade mycket bra till min Ubuntu desktop. Den gav en bra överblick över ändrade filer och vad som
               ändrats i filerna, och det gjorde det enkelt att välja ut filer att commit:a. Så i det här kursmomentet närmar jag mig tio
               commits, även om jag säkert fortfarande ligger hopplöst efter rekommenderat antal.</p>

        </section>

        <section>
            <h2 id="kmom05">Kmom05</h2>
            <p></p>

            <p></p>

            <p></p>

        </section>

        <section>
            <h2 id="kmom06">Kmom06</h2>
            <p></p>

            <p></p>

            <p></p>

        </section>

        <section>
            <h2 id="kmom10">Kmom10</h2>
            <p></p>

            <p></p>

            <p></p>

        </section>
    </article>
{% endblock %}
